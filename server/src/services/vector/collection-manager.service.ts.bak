import { QdrantClient } from '@qdrant/js-client-rest';
import { createServiceLogger } from '../../utils/logger-factory';
import { QdrantClientService } from './qdrant-client.service';
import { 
  IQdrantCollectionService, 
  CollectionCreateOptions, 
  CollectionInfo 
} from './interfaces';

/**
 * Service for managing Qdrant collections
 */
export class QdrantCollectionService implements IQdrantCollectionService {
  private readonly logger = createServiceLogger('QdrantCollectionService');
  private readonly clientService: QdrantClientService;
  private static instance: QdrantCollectionService | null = null;

  private constructor() {
    this.logger.info('QdrantCollectionService initialized');
    this.clientService = QdrantClientService.getInstance();
  }

  /**
   * Get the singleton instance of QdrantCollectionService
   */
  public static getInstance(): QdrantCollectionService {
    if (!QdrantCollectionService.instance) {
      QdrantCollectionService.instance = new QdrantCollectionService();
    }
    return QdrantCollectionService.instance;
  }

  /**
   * Check if a collection exists
   * @param collectionName Collection name to check
   * @returns True if collection exists, false otherwise
   */
  async collectionExists(collectionName: string): Promise<boolean> {
    if (!collectionName) {
      this.logger.error('Collection name is required');
      return false;
    }

    try {
      const client = this.clientService.getClient();
      // List all collections
      const collections = await client.getCollections();
      
      // Check if our collection exists
      const found = collections.collections.some(
        (collection) => collection.name === collectionName
      );
      
      this.logger.info(`Collection ${collectionName} exists: ${found}`);
      return found;
    } catch (error) {
      this.logger.error(`Error checking collection existence: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  /**
   * Create a new collection
   * @param collectionName Collection name
   * @param options Collection creation options
   * @returns True if collection was created successfully
   */
  async createCollection(
    collectionName: string,
    options: CollectionCreateOptions
  ): Promise<boolean> {
    if (!collectionName) {
      this.logger.error('Collection name is required');
      return false;
    }

    try {
      // Check if collection already exists
      const exists = await this.collectionExists(collectionName);
      
      if (exists) {
        this.logger.info(`Collection ${collectionName} already exists`);
        return true;
      }
      
      // Create the collection
      const client = this.clientService.getClient();
      await client.createCollection(collectionName, options);
      
      this.logger.info(`Collection ${collectionName} created with dimension ${options.vectors.size}`);
      return true;
    } catch (error) {
      this.logger.error(`Error creating collection: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  /**
   * Get collection information
   * @param collectionName Collection name
   * @returns Number of vectors in collection or -1 on error
   */
  async getCollectionInfo(collectionName: string): Promise<number> {
    if (!collectionName) {
      this.logger.error('Collection name is required');
      return -1;
    }

    try {
      const client = this.clientService.getClient();
      const exists = await this.collectionExists(collectionName);
      
      if (!exists) {
        this.logger.warn(`Collection ${collectionName} does not exist`);
        return 0;
      }
      
      // Get collection information
      const collectionInfo = await client.getCollection(collectionName);
      
      if (collectionInfo && typeof collectionInfo.vectors_count === 'number') {
        this.logger.info(`Collection ${collectionName} has ${collectionInfo.vectors_count} vectors`);
        return collectionInfo.vectors_count;
      }
      
      this.logger.warn(`Could not retrieve vector count for collection ${collectionName}`);
      return 0;
    } catch (error) {
      this.logger.error(`Error getting collection info: ${error instanceof Error ? error.message : String(error)}`);
      return -1;
    }
  }

  /**
   * Get detailed collection info
   * @param collectionName Collection name
   * @returns Collection info object or null on error
   */
  async getDetailedCollectionInfo(collectionName: string): Promise<CollectionInfo | null> {
    if (!collectionName) {
      this.logger.error('Collection name is required');
      return null;
    }

    try {
      const client = this.clientService.getClient();
      const exists = await this.collectionExists(collectionName);
      
      if (!exists) {
        this.logger.warn(`Collection ${collectionName} does not exist`);
        return null;
      }
      
      // Get collection information
      const collectionInfo = await client.getCollection(collectionName);
      
      if (collectionInfo) {
        const vectorConfig = collectionInfo.config?.params?.vectors;
        
        return {
          name: collectionName,
          vectorCount: collectionInfo.vectors_count || 0,
          dimension: typeof vectorConfig?.size === 'number' ? vectorConfig.size : 0,
          metricType: typeof vectorConfig?.distance === 'string' ? vectorConfig.distance : 'Unknown',
          onDiskPayload: collectionInfo.config?.params?.on_disk_payload || false
        };
      }
      
      return null;
    } catch (error) {
      this.logger.error(`Error getting detailed collection info: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }

  /**
   * Delete a collection
   * @param collectionName Collection name
   * @returns True if collection was deleted successfully
   */
  async deleteCollection(collectionName: string): Promise<boolean> {
    if (!collectionName) {
      this.logger.error('Collection name is required');
      return false;
    }

    try {
      const client = this.clientService.getClient();
      const exists = await this.collectionExists(collectionName);
      
      if (!exists) {
        this.logger.warn(`Collection ${collectionName} does not exist`);
        return true; // Already deleted, consider success
      }
      
      // Delete the collection
      await client.deleteCollection(collectionName);
      
      this.logger.info(`Collection ${collectionName} deleted`);
      return true;
    } catch (error) {
      this.logger.error(`Error deleting collection: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  /**
   * List all collections
   * @returns Array of collection names
   */
  async listCollections(): Promise<string[]> {
    try {
      const client = this.clientService.getClient();
      const collections = await client.getCollections();
      
      const collectionNames = collections.collections.map(
        (collection) => collection.name
      );
      
      this.logger.info(`Found ${collectionNames.length} collections`);
      return collectionNames;
    } catch (error) {
      this.logger.error(`Error listing collections: ${error instanceof Error ? error.message : String(error)}`);
      return [];
    }
  }

  /**
   * Optimize a collection
   * @param collectionName Collection name
   * @returns True if collection was optimized successfully
   */
  async optimizeCollection(collectionName: string): Promise<boolean> {
    if (!collectionName) {
      this.logger.error('Collection name is required');
      return false;
    }

    try {
      const client = this.clientService.getClient();
      const exists = await this.collectionExists(collectionName);
      
      if (!exists) {
        this.logger.warn(`Collection ${collectionName} does not exist`);
        return false;
      }
      
      // Update collection params for optimization
      // Note: This is an unofficial method - in actual implementation 
      // we would use the appropriate client method based on its API
      await client.updateCollection(collectionName, {
        optimizers_config: {
          indexing_threshold: 10000,
          memmap_threshold: 50000
        }
      });
      
      this.logger.info(`Collection ${collectionName} optimized`);
      return true;
    } catch (error) {
      this.logger.error(`Error optimizing collection: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  /**
   * Update collection parameters
   * @param collectionName Collection name
   * @param options Collection update options
   * @returns True if collection was updated successfully
   */
  async updateCollection(
    collectionName: string,
    options: Partial<CollectionCreateOptions>
  ): Promise<boolean> {
    if (!collectionName) {
      this.logger.error('Collection name is required');
      return false;
    }

    try {
      const client = this.clientService.getClient();
      const exists = await this.collectionExists(collectionName);
      
      if (!exists) {
        this.logger.warn(`Collection ${collectionName} does not exist`);
        return false;
      }
      
      // Update collection params
      // Note: These are unofficial methods - in actual implementation
      // we would use the appropriate client methods based on its API
      await client.updateCollection(collectionName, options);
      
      this.logger.info(`Collection ${collectionName} updated`);
      return true;
    } catch (error) {
      this.logger.error(`Error updating collection: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }
} 