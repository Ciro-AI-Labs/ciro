import { createServiceLogger } from '../../utils/logger-factory';
import { OpenAIService } from './openai.service';

/**
 * Service for creating and managing embeddings
 */
export class EmbeddingService {
  private readonly logger = createServiceLogger('EmbeddingService');
  private openaiService: OpenAIService;
  private static instance: EmbeddingService | null = null;

  private constructor() {
    this.logger.info('EmbeddingService initialized');
    this.openaiService = OpenAIService.getInstance();
  }

  /**
   * Get the singleton instance of the service
   */
  public static getInstance(): EmbeddingService {
    if (!EmbeddingService.instance) {
      EmbeddingService.instance = new EmbeddingService();
    }
    return EmbeddingService.instance;
  }

  /**
   * Create embeddings for a text or array of texts
   * @param texts Text or array of texts to create embeddings for
   * @param options Optional settings like skipping cache
   * @returns Array of embeddings (vectors)
   */
  async createEmbeddings(
    texts: string | string[],
    options?: { skipCache?: boolean }
  ): Promise<number[][]> {
    try {
      const textArray = Array.isArray(texts) ? texts : [texts];
      return this.openaiService.createEmbeddings(textArray, options);
    } catch (error) {
      this.logger.error(`Error creating embeddings: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  /**
   * Calculate cosine similarity between two vectors
   * @param vec1 First vector
   * @param vec2 Second vector
   * @returns Cosine similarity (-1 to 1)
   */
  calculateCosineSimilarity(vec1: number[], vec2: number[]): number {
    if (vec1.length !== vec2.length || vec1.length === 0) {
      throw new Error('Vectors must be of the same non-zero length');
    }

    let dotProduct = 0;
    let mag1 = 0;
    let mag2 = 0;

    for (let i = 0; i < vec1.length; i++) {
      dotProduct += vec1[i] * vec2[i];
      mag1 += vec1[i] * vec1[i];
      mag2 += vec2[i] * vec2[i];
    }

    mag1 = Math.sqrt(mag1);
    mag2 = Math.sqrt(mag2);

    if (mag1 === 0 || mag2 === 0) {
      return 0;
    }

    return dotProduct / (mag1 * mag2);
  }

  /**
   * Normalize a vector to unit length
   * @param vector Vector to normalize
   * @returns Normalized vector
   */
  normalizeVector(vector: number[]): number[] {
    const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
    
    if (magnitude === 0) {
      return vector.slice(); // Return a copy of the vector
    }
    
    return vector.map(val => val / magnitude);
  }

  /**
   * Find the most similar text in a collection
   * @param query Query text to compare
   * @param candidates Array of candidate texts
   * @param topK Number of results to return
   * @returns Top K most similar texts with similarity scores
   */
  async findMostSimilar(
    query: string,
    candidates: string[],
    topK: number = 1
  ): Promise<Array<{ text: string; similarity: number }>> {
    try {
      // Create embeddings for query and candidates
      const queryEmbedding = (await this.createEmbeddings(query))[0];
      const candidateEmbeddings = await this.createEmbeddings(candidates);
      
      // Calculate similarities
      const similarities = candidateEmbeddings.map((embedding, index) => ({
        text: candidates[index],
        similarity: this.calculateCosineSimilarity(queryEmbedding, embedding)
      }));
      
      // Sort by similarity (descending) and take top K
      return similarities
        .sort((a, b) => b.similarity - a.similarity)
        .slice(0, topK);
    } catch (error) {
      this.logger.error(`Error finding most similar texts: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
} 