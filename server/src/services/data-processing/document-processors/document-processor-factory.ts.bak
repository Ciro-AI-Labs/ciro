import { BaseDocumentProcessor, ProcessingResult } from './base-document-processor';
import { CustomPdfProcessorService } from './custom-pdf-processor.service';
import { CustomDocxProcessorService } from './custom-docx-processor.service';
import { EnhancedExcelProcessorService } from './enhanced-excel-processor.service';
import { EnhancedCsvProcessorService } from './enhanced-csv-processor.service';
import * as winston from 'winston';
import { OpenAIService } from '../../ai/openai.service';
import { ChunkingService } from '../../rag/chunking.service';
import { ConfigService } from '../../core/config.service';
import { QdrantAdapter } from './qdrant-adapter';
import { SocketAdapter } from './socket-adapter';
import * as path from 'path';
import { WebSocketService } from '../../util/websocket.service';
import { Injectable } from '@nestjs/common';
import { shouldLogInitialization } from '../../../utils/logger-config';
import { QdrantClientService } from '../../vector/qdrant-client.service';
import { QdrantSearchService } from '../../vector/search.service';

@Injectable()
export class DocumentProcessorFactory {
  private processors = new Map<string, BaseDocumentProcessor>();
  private readonly logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: winston.format.combine(
      winston.format.timestamp(),
      winston.format.printf((info) => {
        const { timestamp, level, message, ...rest } = info;
        const formattedMessage = `${timestamp} [${level.toUpperCase()}] [DocumentProcessorFactory]: ${message}`;
        return Object.keys(rest).length ? `${formattedMessage} ${JSON.stringify(rest)}` : formattedMessage;
      })
    ),
    transports: [
      new winston.transports.Console({
        format: winston.format.combine(
          winston.format.colorize(),
          winston.format.timestamp(),
          winston.format.printf((info) => {
            const { timestamp, level, message, ...rest } = info;
            const formattedMessage = `${timestamp} [${level.toUpperCase()}] [DocumentProcessorFactory]: ${message}`;
            return Object.keys(rest).length ? `${formattedMessage} ${JSON.stringify(rest)}` : formattedMessage;
          })
        )
      })
    ]
  });
  private readonly openAIService: OpenAIService;
  private readonly chunkingService: ChunkingService;
  private readonly websocketService: WebSocketService;
  
  // Add singleton implementation
  private static instance: DocumentProcessorFactory | null = null;
  private static constructorCallCount = 0;
  
  /**
   * Get the singleton instance of DocumentProcessorFactory
   */
  public static getInstance(): DocumentProcessorFactory {
    if (!DocumentProcessorFactory.instance) {
      DocumentProcessorFactory.instance = new DocumentProcessorFactory();
    }
    return DocumentProcessorFactory.instance;
  }
  
  /**
   * Get the number of times the constructor has been called
   */
  public static getConstructorCallCount(): number {
    return DocumentProcessorFactory.constructorCallCount;
  }
  
  constructor(
    private configService: ConfigService = ConfigService.getInstance()
  ) {
    DocumentProcessorFactory.constructorCallCount++;
    
    // Warn if constructor is called directly more than once
    if (DocumentProcessorFactory.constructorCallCount > 1 && shouldLogInitialization('DocumentProcessorFactory')) {
      this.logger.warn(`DocumentProcessorFactory constructor called ${DocumentProcessorFactory.constructorCallCount} times. Use DocumentProcessorFactory.getInstance() instead of new DocumentProcessorFactory().`);
    }
    
    this.openAIService = OpenAIService.getInstance();
    this.chunkingService = ChunkingService.getInstance();
    this.websocketService = new WebSocketService();
    this.initialize();
    
    if (shouldLogInitialization('DocumentProcessorFactory')) {
      this.logger.info('Document processor factory initialized');
      this.logger.info(`Registered processors: ${Array.from(this.processors.keys()).join(', ')}`);
    }
  }
  
  /**
   * Initialize the factory and register default processors
   */
  private initialize() {
    this.logger.info('Initializing DocumentProcessorFactory');
    
    try {
      // Initialize processor services
      this.logger.debug('Creating instances of processor services');
      const configService = ConfigService.getInstance();
      const chunkingService = ChunkingService.getInstance();
      const qdrantAdapter = QdrantAdapter.getInstance();
      const socketAdapter = SocketAdapter.getInstance();
      
      // Get adapter services
      const socketService = socketAdapter.getSocketServiceAdapter();
      
      // Initialize Excel processor (enhanced version)
      try {
        this.logger.debug('Initializing Enhanced Excel Processor');
        const excelProcessor = new EnhancedExcelProcessorService(
          configService,
          chunkingService,
          QdrantClientService.getInstance()
        );
        // Register with multiple keys to ensure it's found regardless of how it's referenced
        this.registerProcessor(['.xlsx', '.xls', '.ods', 'excel', 'xlsx', 'xls', 'ods', 'excel-processor'], excelProcessor);
        this.logger.info('Enhanced Excel Processor registered successfully');
      } catch (err) {
        this.logger.error(`Failed to initialize Enhanced Excel Processor: ${err}`);
      }
      
      // Initialize custom PDF processor
      try {
        this.logger.debug('Initializing Custom PDF Processor');
        const pdfProcessor = new CustomPdfProcessorService(
          configService,
          chunkingService,
          socketService
        );
        this.registerProcessor(['.pdf'], pdfProcessor);
        this.logger.info('Custom PDF Processor registered successfully');
      } catch (err) {
        this.logger.error(`Failed to initialize Custom PDF Processor: ${err}`);
      }
      
      // Initialize custom DOCX processor
      try {
        this.logger.debug('Initializing Custom DOCX Processor');
        const docxProcessor = new CustomDocxProcessorService(
          configService,
          chunkingService,
          QdrantClientService.getInstance()
        );
        this.registerProcessor(['.docx', '.doc'], docxProcessor);
        this.logger.info('Custom DOCX Processor registered successfully');
      } catch (err) {
        this.logger.error(`Failed to initialize Custom DOCX Processor: ${err}`);
      }
      
      // Initialize CSV processor and register under multiple keys
      try {
        this.logger.debug('Initializing Enhanced CSV Processor');
        const csvProcessor = new EnhancedCsvProcessorService(
          configService,
          chunkingService,
          QdrantSearchService.getInstance(),
          socketService
        );
        this.registerProcessor(['.csv', 'csv', 'csv-processor'], csvProcessor);
        this.logger.info('Enhanced CSV Processor registered successfully');
      } catch (err) {
        this.logger.error(`Failed to initialize Enhanced CSV Processor: ${err}`);
      }
      
      // Register 'auto' processor strategy that will detect file type and use appropriate processor
      this.registerProcessor(['auto'], {
        processFile: async (filePath: string, dataSourceId: string, metadata: Record<string, any> = {}) => {
          this.logger.info(`Auto processor handling file: ${filePath}`);
          
          // Get file extension
          const fileExtension = path.extname(filePath).toLowerCase();
          this.logger.info(`File extension detected: ${fileExtension}`);
          
          // Get appropriate processor based on file extension
          const processor = this.getProcessorByPath(filePath);
          
          if (!processor) {
            this.logger.error(`No suitable processor found for ${filePath} with extension ${fileExtension}`);
            return {
              status: 'error',
              message: `Unsupported file type: ${fileExtension}`,
              chunks: 0,
              metadata: { error: 'unsupported_file_type' }
            };
          }
          
          this.logger.info(`Using processor for extension ${fileExtension} to process file: ${path.basename(filePath)}`);
          return processor.processFile(filePath, dataSourceId, metadata);
        }
      } as BaseDocumentProcessor);
      
      this.logger.info('Auto processor strategy registered successfully');
    } catch (err) {
      this.logger.error(`Failed to initialize DocumentProcessorFactory: ${err}`);
    }
  }
  
  /**
   * Register a processor for a specific file type
   * @param fileTypes Array of file types (extensions)
   * @param processor Processor instance
   */
  registerProcessor(fileTypes: string[], processor: BaseDocumentProcessor): void {
    fileTypes.forEach(fileType => {
      this.processors.set(fileType.toLowerCase(), processor);
      this.logger.debug(`Registered processor for ${fileType}: ${processor.constructor.name}`);
    });
  }
  
  /**
   * Get processor for a specific file type
   * @param fileType File type or extension
   * @returns Document processor or null if none found
   */
  getProcessor(fileTypeOrPath: string): BaseDocumentProcessor | null {
    this.logger.debug(`Getting processor for: ${fileTypeOrPath}`);
    
    // Handle null or undefined file type
    if (!fileTypeOrPath) {
      this.logger.warn('No file type provided to getProcessor');
      return null;
    }
    
    // Handle special case for 'auto' processing method
    if (fileTypeOrPath.toLowerCase() === 'auto') {
      this.logger.info(`Auto processing method detected, will determine processor based on file extension`);
      // This will be handled by getProcessorByPath when the actual file path is provided
      // For now, just log the information and return null
      return null;
    }
    
    // Convert to lowercase and remove any leading dot
    const normalizedType = fileTypeOrPath.toLowerCase().replace(/^\./, '');
    
    if (this.processors.has(normalizedType)) {
      this.logger.debug(`Found processor for ${normalizedType}: ${this.processors.get(normalizedType)?.constructor.name}`);
      return this.processors.get(normalizedType) || null;
    }
    
    this.logger.warn(`No processor found for file type: ${fileTypeOrPath}`);
    return null;
  }
  
  /**
   * Get processor based on file extension
   * @param filePath Path to the file
   * @returns Document processor or null if none found
   */
  getProcessorByPath(filePath: string): BaseDocumentProcessor | null {
    this.logger.debug(`Getting processor by path: ${filePath}`);
    
    if (!filePath) {
      this.logger.warn('No file path provided to getProcessorByPath');
      return null;
    }
    
    // Get the file extension
    const fileExtension = path.extname(filePath).toLowerCase();
    
    if (!fileExtension) {
      this.logger.warn(`No file extension found for path: ${filePath}`);
      return null;
    }
    
    // Try to get processor directly by extension
    const processor = this.processors.get(fileExtension);
    
    if (processor) {
      this.logger.info(`Found processor for ${fileExtension}: ${processor.constructor.name}`);
      return processor;
    }
    
    this.logger.warn(`No processor found for file type: ${fileExtension}`);
    return null;
  }
  
  /**
   * Get processor based on file type
   * @param fileType Type of the file
   * @returns Document processor
   * @throws Error if no processor registered for the file type
   */
  getProcessorByFileType(fileType: string): BaseDocumentProcessor | null {
    this.logger.debug(`Getting processor by file type: ${fileType}`);
    
    if (!fileType) {
      this.logger.warn('No file type provided to getProcessorByFileType');
      return null;
    }
    
    // Normalize file type to lowercase
    const normalizedType = fileType.toLowerCase();
    
    // Try with dot prefix if not found directly
    if (!normalizedType.startsWith('.')) {
      const withDot = `.${normalizedType}`;
      const processorWithDot = this.processors.get(withDot);
      if (processorWithDot) {
        this.logger.info(`Found processor for file type with dot prefix: ${withDot}`);
        return processorWithDot;
      }
    }
    
    // Standard lookup
    const processor = this.processors.get(normalizedType);
    
    if (!processor) {
      this.logger.warn(`No processor registered for file type: ${fileType}`);
      return null;
    }
    
    return processor;
  }
}