/**
 * Context Builder for RAG
 * 
 * This module contains utilities for building context from retrieved documents
 * for use in RAG (Retrieval Augmented Generation).
 */

import { Document } from './interfaces';
import { createServiceLogger } from '../../utils/logger-factory';

/**
 * Context format options
 */
export type ContextFormat = 'default' | 'numbered' | 'markdown' | 'compact';

/**
 * Options for building context
 */
export interface ContextBuilderOptions {
  maxTokens?: number;
  format?: ContextFormat;
  includeMetadata?: boolean;
  deduplicate?: boolean;
}

/**
 * Class to build context strings from retrieved documents
 */
export class ContextBuilder {
  private readonly logger = createServiceLogger('ContextBuilder');
  private static instance: ContextBuilder | null = null;

  private constructor() {
    this.logger.info('ContextBuilder initialized');
  }

  /**
   * Get singleton instance
   */
  public static getInstance(): ContextBuilder {
    if (!ContextBuilder.instance) {
      ContextBuilder.instance = new ContextBuilder();
    }
    return ContextBuilder.instance;
  }

  /**
   * Build a context string from retrieved documents
   */
  buildContext(
    documents: Document[],
    options: ContextBuilderOptions = {}
  ): string {
    if (!documents || documents.length === 0) {
      return '';
    }

    // Apply default options
    const {
      maxTokens = 4000,
      format = 'default',
      includeMetadata = true,
      deduplicate = true
    } = options;

    // Deduplicate documents if needed
    const docs = deduplicate ? this.deduplicateDocuments(documents) : documents;

    // Sort by similarity score if available
    const sortedDocs = [...docs].sort((a, b) => {
      return (b.similarity || 0) - (a.similarity || 0);
    });

    // Format according to selected style
    switch (format) {
      case 'numbered':
        return this.buildNumberedContext(sortedDocs, includeMetadata);
      case 'markdown':
        return this.buildMarkdownContext(sortedDocs, includeMetadata);
      case 'compact':
        return this.buildCompactContext(sortedDocs, includeMetadata);
      case 'default':
      default:
        return this.buildDefaultContext(sortedDocs, includeMetadata);
    }
  }

  /**
   * Deduplicate documents based on content similarity
   */
  private deduplicateDocuments(documents: Document[]): Document[] {
    const uniqueDocs: Document[] = [];
    const seenContent = new Set<string>();

    for (const doc of documents) {
      // Create a normalized representation of the content
      const contentKey = doc.content.trim().toLowerCase().slice(0, 100);
      
      // Skip if we've seen this content before
      if (seenContent.has(contentKey)) {
        continue;
      }

      seenContent.add(contentKey);
      uniqueDocs.push(doc);
    }

    return uniqueDocs;
  }

  /**
   * Build default context format
   */
  private buildDefaultContext(documents: Document[], includeMetadata: boolean): string {
    return documents.map((doc, index) => {
      const metadata = includeMetadata && doc.metadata 
        ? `\nSource: ${this.formatMetadata(doc.metadata)}`
        : '';
      
      return `[Document ${index + 1}]${metadata}\n${doc.content.trim()}`;
    }).join('\n\n');
  }

  /**
   * Build numbered context format
   */
  private buildNumberedContext(documents: Document[], includeMetadata: boolean): string {
    return documents.map((doc, index) => {
      const metadata = includeMetadata && doc.metadata 
        ? `\nSource: ${this.formatMetadata(doc.metadata)}`
        : '';
      
      return `Document ${index + 1}:${metadata}\n${doc.content.trim()}`;
    }).join('\n\n');
  }

  /**
   * Build markdown context format
   */
  private buildMarkdownContext(documents: Document[], includeMetadata: boolean): string {
    return documents.map((doc, index) => {
      const metadata = includeMetadata && doc.metadata 
        ? `\n*Source: ${this.formatMetadata(doc.metadata)}*`
        : '';
      
      return `### Document ${index + 1}${metadata}\n\n${doc.content.trim()}`;
    }).join('\n\n');
  }

  /**
   * Build compact context format (no headers, just content)
   */
  private buildCompactContext(documents: Document[], includeMetadata: boolean): string {
    return documents.map(doc => doc.content.trim()).join('\n\n');
  }

  /**
   * Format metadata object into a string
   */
  private formatMetadata(metadata: Record<string, any>): string {
    if (!metadata) return '';

    // Extract key properties if they exist
    const title = metadata.title || metadata.name || '';
    const source = metadata.source || metadata.url || '';
    const author = metadata.author || '';
    const date = metadata.date || metadata.createdAt || '';

    // Format into a readable string
    const parts = [];
    if (title) parts.push(title);
    if (source) parts.push(source);
    if (author) parts.push(`by ${author}`);
    if (date) parts.push(`(${date})`);

    return parts.join(' ');
  }
}

export const contextBuilder = ContextBuilder.getInstance(); 